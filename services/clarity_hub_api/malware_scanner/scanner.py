"""
YARA-Based Malware Scanner
Provides file scanning capabilities using YARA rules
"""

import os
import hashlib
import logging
from typing import Dict, List, Optional, BinaryIO, Any
from datetime import datetime
from dataclasses import dataclass, asdict
from pathlib import Path

try:
    import yara  # type: ignore
    YARA_AVAILABLE = True
except ImportError:
    YARA_AVAILABLE = False
    logging.warning("YARA not available. Install yara-python to enable malware scanning.")


@dataclass
class YaraMatch:
    """Represents a YARA rule match"""
    rule_name: str
    description: str
    severity: str
    malware_type: str
    tags: List[str]
    strings: List[Dict]
    
    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return asdict(self)


@dataclass
class ScanResult:
    """Represents the result of a malware scan"""
    file_name: str
    file_size: int
    md5_hash: str
    sha1_hash: str
    sha256_hash: str
    scan_time: str
    is_malicious: bool
    threat_level: str  # "clean", "low", "medium", "high", "critical"
    matches: List[YaraMatch]
    error: Optional[str] = None
    
    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return {
            "file_name": self.file_name,
            "file_size": self.file_size,
            "md5_hash": self.md5_hash,
            "sha1_hash": self.sha1_hash,
            "sha256_hash": self.sha256_hash,
            "scan_time": self.scan_time,
            "is_malicious": self.is_malicious,
            "threat_level": self.threat_level,
            "matches": [m.to_dict() for m in self.matches],
            "error": self.error
        }


class MalwareScanner:
    """YARA-based malware scanner"""
    
    def __init__(self, rules_path: Optional[str] = None):
        """
        Initialize the malware scanner
        
        Args:
            rules_path: Path to YARA rules file. If None, uses default rules.
        """
        if not YARA_AVAILABLE:
            raise RuntimeError("YARA is not installed. Install yara-python to use malware scanning.")
        
        self.logger = logging.getLogger(__name__)
        
        # Use default rules if not specified
        if rules_path is None:
            rules_path = os.path.join(
                os.path.dirname(__file__),
                "rules.yar"
            )
        
        self.rules_path = rules_path
        self.rules: Optional[Any] = None
        self._load_rules()
    
    def _load_rules(self) -> None:
        """Load YARA rules from file"""
        try:
            if not os.path.exists(self.rules_path):
                raise FileNotFoundError(f"YARA rules file not found: {self.rules_path}")
            
            self.rules = yara.compile(filepath=self.rules_path)
            self.logger.info(f"Successfully loaded YARA rules from {self.rules_path}")
        except Exception as e:
            self.logger.error(f"Failed to load YARA rules: {e}")
            raise
    
    def reload_rules(self) -> None:
        """Reload YARA rules from file"""
        self._load_rules()
    
    @staticmethod
    def calculate_hashes(file_data: bytes) -> Dict[str, str]:
        """
        Calculate MD5, SHA1, and SHA256 hashes of file data
        
        Args:
            file_data: File content as bytes
            
        Returns:
            Dictionary with hash values
        """
        return {
            "md5": hashlib.md5(file_data).hexdigest(),
            "sha1": hashlib.sha1(file_data).hexdigest(),
            "sha256": hashlib.sha256(file_data).hexdigest()
        }
    
    def _determine_threat_level(self, matches: List[YaraMatch]) -> str:
        """
        Determine overall threat level based on matches
        
        Args:
            matches: List of YARA matches
            
        Returns:
            Threat level string
        """
        if not matches:
            return "clean"
        
        # Find highest severity
        severity_levels = {
            "critical": 4,
            "high": 3,
            "medium": 2,
            "low": 1
        }
        
        max_severity = max(
            (severity_levels.get(match.severity.lower(), 0) for match in matches),
            default=0
        )
        
        for severity, level in severity_levels.items():
            if level == max_severity:
                return severity
        
        return "low"
    
    def scan_file(self, file_path: str) -> ScanResult:
        """
        Scan a file for malware
        
        Args:
            file_path: Path to file to scan
            
        Returns:
            ScanResult object
        """
        try:
            # Read file
            with open(file_path, 'rb') as f:
                file_data = f.read()
            
            return self.scan_bytes(
                file_data=file_data,
                file_name=os.path.basename(file_path)
            )
        
        except Exception as e:
            self.logger.error(f"Error scanning file {file_path}: {e}")
            return ScanResult(
                file_name=os.path.basename(file_path),
                file_size=0,
                md5_hash="",
                sha1_hash="",
                sha256_hash="",
                scan_time=datetime.utcnow().isoformat(),
                is_malicious=False,
                threat_level="error",
                matches=[],
                error=str(e)
            )
    
    def scan_bytes(self, file_data: bytes, file_name: str = "unknown") -> ScanResult:
        """
        Scan file data bytes for malware
        
        Args:
            file_data: File content as bytes
            file_name: Name of the file being scanned
            
        Returns:
            ScanResult object
        """
        try:
            # Calculate hashes
            hashes = self.calculate_hashes(file_data)
            
            # Scan with YARA
            if self.rules is None:
                raise RuntimeError("YARA rules not loaded")
            yara_matches = self.rules.match(data=file_data)
            
            # Convert YARA matches to our format
            matches = []
            for match in yara_matches:
                # Extract metadata
                meta = match.meta
                
                # Extract matched strings
                matched_strings = []
                for string_match in match.strings:
                    instances_list = []
                    for instance in string_match.instances:
                        try:
                            # YARA instances are objects with offset and matched_data attributes
                            instances_list.append({
                                "offset": instance.offset,
                                "matched_data": instance.matched_data.decode('utf-8', errors='replace')[:100]
                            })
                        except Exception as e:
                            # Fallback for different YARA versions
                            self.logger.debug(f"Error extracting instance: {e}")
                            instances_list.append({
                                "offset": 0,
                                "matched_data": str(instance)[:100]
                            })
                    
                    matched_strings.append({
                        "identifier": string_match.identifier,
                        "instances": instances_list
                    })
                
                yara_match = YaraMatch(
                    rule_name=match.rule,
                    description=meta.get("description", "No description"),
                    severity=meta.get("severity", "medium"),
                    malware_type=meta.get("malware_type", "unknown"),
                    tags=match.tags,
                    strings=matched_strings
                )
                matches.append(yara_match)
            
            # Determine threat level
            threat_level = self._determine_threat_level(matches)
            is_malicious = len(matches) > 0
            
            return ScanResult(
                file_name=file_name,
                file_size=len(file_data),
                md5_hash=hashes["md5"],
                sha1_hash=hashes["sha1"],
                sha256_hash=hashes["sha256"],
                scan_time=datetime.utcnow().isoformat(),
                is_malicious=is_malicious,
                threat_level=threat_level,
                matches=matches
            )
        
        except Exception as e:
            self.logger.error(f"Error scanning file data: {e}")
            return ScanResult(
                file_name=file_name,
                file_size=len(file_data),
                md5_hash="",
                sha1_hash="",
                sha256_hash="",
                scan_time=datetime.utcnow().isoformat(),
                is_malicious=False,
                threat_level="error",
                matches=[],
                error=str(e)
            )
    
    def get_available_rules(self) -> List[Dict]:
        """
        Get list of available YARA rules
        
        Returns:
            List of rule information dictionaries
        """
        try:
            rules_info = []
            
            # Read rules file to extract rule names and metadata
            with open(self.rules_path, 'r') as f:
                content = f.read()
            
            # Simple parsing to extract rule names (this is basic, could be improved)
            import re
            rule_pattern = r'rule\s+(\w+)\s*\{'
            meta_pattern = r'meta:\s*\n((?:\s+\w+\s*=\s*"[^"]*"\s*\n)+)'
            
            for rule_match in re.finditer(rule_pattern, content):
                rule_name = rule_match.group(1)
                
                # Try to find metadata for this rule
                meta_start = rule_match.end()
                meta_section = content[meta_start:meta_start + 500]
                meta_match = re.match(meta_pattern, meta_section)
                
                meta_dict = {"rule_name": rule_name}
                
                if meta_match:
                    meta_text = meta_match.group(1)
                    # Extract meta fields
                    for meta_line in meta_text.strip().split('\n'):
                        meta_line = meta_line.strip()
                        if '=' in meta_line:
                            key, value = meta_line.split('=', 1)
                            key = key.strip()
                            value = value.strip().strip('"')
                            meta_dict[key] = value
                
                rules_info.append(meta_dict)
            
            return rules_info
        
        except Exception as e:
            self.logger.error(f"Error getting available rules: {e}")
            return []
    
    def test_eicar(self) -> ScanResult:
        """
        Test scanner with EICAR test string
        
        Returns:
            ScanResult for EICAR test
        """
        # EICAR test string
        eicar = b'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*'
        
        return self.scan_bytes(eicar, "eicar.com")


# Convenience function for quick scanning
def scan_file(file_path: str, rules_path: Optional[str] = None) -> ScanResult:
    """
    Quick file scan function
    
    Args:
        file_path: Path to file to scan
        rules_path: Optional custom rules path
        
    Returns:
        ScanResult object
    """
    scanner = MalwareScanner(rules_path=rules_path)
    return scanner.scan_file(file_path)

"""
YARA-Based Malware Scanner
Provides file scanning capabilities using YARA rules with memory-safe streaming
"""

import os
import hashlib
import logging
from typing import Dict, List, Optional, BinaryIO, Any
from datetime import datetime
from dataclasses import dataclass, asdict
from pathlib import Path
import tempfile

# Security configuration
MAX_FILE_SIZE = 100 * 1024 * 1024  # 100MB in bytes
CHUNK_SIZE = 8192  # 8KB chunks for streaming
MAX_MEMORY_SCAN = 50 * 1024 * 1024  # 50MB - scan small files in memory

try:
    import yara  # type: ignore
    YARA_AVAILABLE = True
except ImportError:
    YARA_AVAILABLE = False
    logging.warning("YARA not available. Install yara-python to enable malware scanning.")


@dataclass
class YaraMatch:
    """Represents a YARA rule match"""
    rule_name: str
    description: str
    severity: str
    malware_type: str
    tags: List[str]
    strings: List[Dict]
    
    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return asdict(self)


@dataclass
class ScanResult:
    """Represents the result of a malware scan"""
    file_name: str
    file_size: int
    md5_hash: str
    sha1_hash: str
    sha256_hash: str
    scan_time: str
    is_malicious: bool
    threat_level: str  # "clean", "low", "medium", "high", "critical"
    matches: List[YaraMatch]
    error: Optional[str] = None
    size_limit_exceeded: bool = False  # New field to track size violations
    
    def to_dict(self) -> Dict:
        """Convert to dictionary"""
        return {
            "file_name": self.file_name,
            "file_size": self.file_size,
            "md5_hash": self.md5_hash,
            "sha1_hash": self.sha1_hash,
            "sha256_hash": self.sha256_hash,
            "scan_time": self.scan_time,
            "is_malicious": self.is_malicious,
            "threat_level": self.threat_level,
            "matches": [m.to_dict() for m in self.matches],
            "error": self.error,
            "size_limit_exceeded": self.size_limit_exceeded
        }


class FileSizeLimitError(Exception):
    """Raised when file exceeds maximum size limit"""
    pass


class MalwareScanner:
    """YARA-based malware scanner"""
    
    def __init__(self, rules_path: Optional[str] = None):
        """
        Initialize the malware scanner
        
        Args:
            rules_path: Path to YARA rules file. If None, uses default rules.
        """
        if not YARA_AVAILABLE:
            raise RuntimeError("YARA is not installed. Install yara-python to use malware scanning.")
        
        self.logger = logging.getLogger(__name__)
        
        # Use default rules if not specified
        if rules_path is None:
            rules_path = os.path.join(
                os.path.dirname(__file__),
                "rules.yar"
            )
        
        self.rules_path = rules_path
        self.rules: Optional[Any] = None
        self._load_rules()
    
    def _load_rules(self) -> None:
        """Load YARA rules from file"""
        try:
            if not os.path.exists(self.rules_path):
                raise FileNotFoundError(f"YARA rules file not found: {self.rules_path}")
            
            self.rules = yara.compile(filepath=self.rules_path)
            self.logger.info(f"Successfully loaded YARA rules from {self.rules_path}")
        except Exception as e:
            self.logger.error(f"Failed to load YARA rules: {e}")
            raise
    
    def reload_rules(self) -> None:
        """Reload YARA rules from file"""
        self._load_rules()
    
    @staticmethod
    def calculate_hashes(file_data: bytes) -> Dict[str, str]:
        """
        Calculate MD5, SHA1, and SHA256 hashes of file data
        
        Args:
            file_data: File content as bytes
            
        Returns:
            Dictionary with hash values
        """
        return {
            "md5": hashlib.md5(file_data).hexdigest(),
            "sha1": hashlib.sha1(file_data).hexdigest(),
            "sha256": hashlib.sha256(file_data).hexdigest()
        }
    
    @staticmethod
    def calculate_hashes_streaming(file_path: str) -> Dict[str, str]:
        """
        Calculate hashes by streaming file (memory-efficient for large files)
        
        Args:
            file_path: Path to file
            
        Returns:
            Dictionary with hash values
        """
        md5 = hashlib.md5()
        sha1 = hashlib.sha1()
        sha256 = hashlib.sha256()
        
        with open(file_path, 'rb') as f:
            while chunk := f.read(CHUNK_SIZE):
                md5.update(chunk)
                sha1.update(chunk)
                sha256.update(chunk)
        
        return {
            "md5": md5.hexdigest(),
            "sha1": sha1.hexdigest(),
            "sha256": sha256.hexdigest()
        }
    
    @staticmethod
    def validate_file_size(file_size: int, max_size: int = MAX_FILE_SIZE) -> None:
        """
        Validate file size against maximum limit
        
        Args:
            file_size: Size of file in bytes
            max_size: Maximum allowed size in bytes
            
        Raises:
            FileSizeLimitError: If file exceeds size limit
        """
        if file_size > max_size:
            raise FileSizeLimitError(
                f"File size ({file_size / 1024 / 1024:.2f} MB) exceeds "
                f"maximum allowed size ({max_size / 1024 / 1024:.2f} MB)"
            )
    
    def _determine_threat_level(self, matches: List[YaraMatch]) -> str:
        """
        Determine overall threat level based on matches
        
        Args:
            matches: List of YARA matches
            
        Returns:
            Threat level string
        """
        if not matches:
            return "clean"
        
        # Find highest severity
        severity_levels = {
            "critical": 4,
            "high": 3,
            "medium": 2,
            "low": 1
        }
        
        max_severity = max(
            (severity_levels.get(match.severity.lower(), 0) for match in matches),
            default=0
        )
        
        for severity, level in severity_levels.items():
            if level == max_severity:
                return severity
        
        return "low"
    
    def _process_yara_matches(self, yara_matches: Any) -> List[YaraMatch]:
        """
        Process YARA matches into YaraMatch objects
        
        Args:
            yara_matches: Raw YARA match objects
            
        Returns:
            List of YaraMatch objects
        """
        matches = []
        for match in yara_matches:
            # Extract metadata
            meta = match.meta
            self.logger.debug(f"Processing match: {match.rule}")
            self.logger.debug(f"Metadata: {meta}")
            
            # Extract matched strings
            matched_strings = []
            for string_match in match.strings:
                instances_list = []
                for instance in string_match.instances:
                    try:
                        # YARA instances are objects with offset and matched_data attributes
                        instances_list.append({
                            "offset": instance.offset,
                            "matched_data": instance.matched_data.decode('utf-8', errors='replace')[:100]
                        })
                    except Exception as e:
                        # Fallback for different YARA versions
                        self.logger.debug(f"Error extracting instance: {e}")
                        instances_list.append({
                            "offset": 0,
                            "matched_data": str(instance)[:100]
                        })
                
                matched_strings.append({
                    "identifier": string_match.identifier,
                    "instances": instances_list
                })
            
            yara_match = YaraMatch(
                rule_name=match.rule,
                description=meta.get("description", "No description"),
                severity=meta.get("severity", "medium"),
                malware_type=meta.get("malware_type", "unknown"),
                tags=match.tags,
                strings=matched_strings
            )
            matches.append(yara_match)
        
        return matches
    
    def scan_file(self, file_path: str, max_size: int = MAX_FILE_SIZE) -> ScanResult:
        """
        Scan a file for malware (memory-efficient for large files)
        
        Args:
            file_path: Path to file to scan
            max_size: Maximum file size to scan (default: 100MB)
            
        Returns:
            ScanResult object
        """
        try:
            # Get file size first without reading content
            file_size = os.path.getsize(file_path)
            file_name = os.path.basename(file_path)
            
            # Validate file size before reading
            try:
                self.validate_file_size(file_size, max_size)
            except FileSizeLimitError as e:
                self.logger.warning(f"File size limit exceeded: {file_name} ({file_size / 1024 / 1024:.2f} MB)")
                return ScanResult(
                    file_name=file_name,
                    file_size=file_size,
                    md5_hash="",
                    sha1_hash="",
                    sha256_hash="",
                    scan_time=datetime.utcnow().isoformat(),
                    is_malicious=False,
                    threat_level="error",
                    matches=[],
                    error=str(e),
                    size_limit_exceeded=True
                )
            
            # For small files, scan in memory (faster)
            if file_size <= MAX_MEMORY_SCAN:
                with open(file_path, 'rb') as f:
                    file_data = f.read()
                return self.scan_bytes(file_data=file_data, file_name=file_name)
            
            # For large files, use streaming approach
            else:
                self.logger.info(f"Scanning large file ({file_size / 1024 / 1024:.2f} MB): {file_name}")
                
                # Calculate hashes efficiently
                hashes = self.calculate_hashes_streaming(file_path)
                
                # Scan with YARA (YARA can scan files directly)
                if self.rules is None:
                    raise RuntimeError("YARA rules not loaded")
                
                yara_matches = self.rules.match(filepath=file_path)
                
                # Convert YARA matches
                matches = self._process_yara_matches(yara_matches)
                
                # Determine threat level
                threat_level = self._determine_threat_level(matches)
                is_malicious = len(matches) > 0
                
                return ScanResult(
                    file_name=file_name,
                    file_size=file_size,
                    md5_hash=hashes["md5"],
                    sha1_hash=hashes["sha1"],
                    sha256_hash=hashes["sha256"],
                    scan_time=datetime.utcnow().isoformat(),
                    is_malicious=is_malicious,
                    threat_level=threat_level,
                    matches=matches
                )
        
        except FileSizeLimitError as e:
            # Already handled above, but catch in case
            raise
        except Exception as e:
            self.logger.error(f"Error scanning file {file_path}: {e}")
            return ScanResult(
                file_name=os.path.basename(file_path),
                file_size=0,
                md5_hash="",
                sha1_hash="",
                sha256_hash="",
                scan_time=datetime.utcnow().isoformat(),
                is_malicious=False,
                threat_level="error",
                matches=[],
                error=str(e)
            )
    
    def scan_bytes(self, file_data: bytes, file_name: str = "unknown", max_size: int = MAX_FILE_SIZE) -> ScanResult:
        """
        Scan file data bytes for malware (with size validation)
        
        Args:
            file_data: File content as bytes
            file_name: Name of the file being scanned
            max_size: Maximum file size to scan (default: 100MB)
            
        Returns:
            ScanResult object
        """
        try:
            # Validate size before processing
            file_size = len(file_data)
            try:
                self.validate_file_size(file_size, max_size)
            except FileSizeLimitError as e:
                self.logger.warning(f"File size limit exceeded: {file_name} ({file_size / 1024 / 1024:.2f} MB)")
                return ScanResult(
                    file_name=file_name,
                    file_size=file_size,
                    md5_hash="",
                    sha1_hash="",
                    sha256_hash="",
                    scan_time=datetime.utcnow().isoformat(),
                    is_malicious=False,
                    threat_level="error",
                    matches=[],
                    error=str(e),
                    size_limit_exceeded=True
                )
            
            # Calculate hashes
            hashes = self.calculate_hashes(file_data)
            
            # Scan with YARA
            if self.rules is None:
                raise RuntimeError("YARA rules not loaded")
            yara_matches = self.rules.match(data=file_data)
            
            # Convert YARA matches using helper method
            matches = self._process_yara_matches(yara_matches)
            
            # Determine threat level
            threat_level = self._determine_threat_level(matches)
            is_malicious = len(matches) > 0
            
            return ScanResult(
                file_name=file_name,
                file_size=file_size,
                md5_hash=hashes["md5"],
                sha1_hash=hashes["sha1"],
                sha256_hash=hashes["sha256"],
                scan_time=datetime.utcnow().isoformat(),
                is_malicious=is_malicious,
                threat_level=threat_level,
                matches=matches
            )
        
        except FileSizeLimitError:
            # Already handled above
            raise
        except Exception as e:
            self.logger.error(f"Error scanning file data: {e}")
            return ScanResult(
                file_name=file_name,
                file_size=len(file_data) if file_data else 0,
                md5_hash="",
                sha1_hash="",
                sha256_hash="",
                scan_time=datetime.utcnow().isoformat(),
                is_malicious=False,
                threat_level="error",
                matches=[],
                error=str(e)
            )
    
    def get_available_rules(self) -> List[Dict]:
        """
        Get list of available YARA rules
        
        Returns:
            List of rule information dictionaries
        """
        try:
            rules_info = []
            
            # Read rules file to extract rule names and metadata
            with open(self.rules_path, 'r') as f:
                content = f.read()
            
            # Simple parsing to extract rule names (this is basic, could be improved)
            import re
            rule_pattern = r'rule\s+(\w+)\s*\{'
            meta_pattern = r'meta:\s*\n((?:\s+\w+\s*=\s*"[^"]*"\s*\n)+)'
            
            for rule_match in re.finditer(rule_pattern, content):
                rule_name = rule_match.group(1)
                
                # Try to find metadata for this rule
                meta_start = rule_match.end()
                meta_section = content[meta_start:meta_start + 500]
                meta_match = re.match(meta_pattern, meta_section)
                
                meta_dict = {"rule_name": rule_name}
                
                if meta_match:
                    meta_text = meta_match.group(1)
                    # Extract meta fields
                    for meta_line in meta_text.strip().split('\n'):
                        meta_line = meta_line.strip()
                        if '=' in meta_line:
                            key, value = meta_line.split('=', 1)
                            key = key.strip()
                            value = value.strip().strip('"')
                            meta_dict[key] = value
                
                rules_info.append(meta_dict)
            
            return rules_info
        
        except Exception as e:
            self.logger.error(f"Error getting available rules: {e}")
            return []
    
    def test_eicar(self) -> ScanResult:
        """
        Test scanner with EICAR test string
        
        Returns:
            ScanResult for EICAR test
        """
        # EICAR test string
        eicar = b'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*'
        
        return self.scan_bytes(eicar, "eicar.com")


# Convenience function for quick scanning
def scan_file(file_path: str, rules_path: Optional[str] = None) -> ScanResult:
    """
    Quick file scan function
    
    Args:
        file_path: Path to file to scan
        rules_path: Optional custom rules path
        
    Returns:
        ScanResult object
    """
    scanner = MalwareScanner(rules_path=rules_path)
    return scanner.scan_file(file_path)
